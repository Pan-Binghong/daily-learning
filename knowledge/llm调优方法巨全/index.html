<!doctype html><html lang=en dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>LLM调优方法|巨™全 | Pan Binghong's Tech Blog</title><meta name=keywords content="Knowledge"><meta name=description content="
💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。

算效调优
硬件层面各个部件对大模型的优化策略
1. GPU加速
1.1 为什么GPU可以对大模型有加速效果?
GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。

选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。

并行处理能力：
高吞吐量：
大规模计算：
优化的库和框架：
成本：

1.2 GPU里有什么,?
Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：
CUDA Cores
CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。
CUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。
Tensor Cores
Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。
Tensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。
CUDA Cores&amp;Tensor Cores区别

应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。
计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。
性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。
CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。

1.3 主流GPU性能对比

1.4 训练/推理最佳配置
训练最优配置

推理最优配置
"><meta name=author content="Pan Binghong"><link rel=canonical href=https://Pan-Binghong.github.io/daily-learning/knowledge/llm%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%B7%A8%E5%85%A8/><link crossorigin=anonymous href=/daily-learning/assets/css/stylesheet.8c4274f6592e00e67f9d9e38f6a29695c6a6ce5eded446ed371ff6565dbb189f.css integrity="sha256-jEJ09lkuAOZ/nZ449qKWlcamzl7e1EbtNx/2Vl27GJ8=" rel="preload stylesheet" as=style><link rel=icon href=https://Pan-Binghong.github.io/daily-learning/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://Pan-Binghong.github.io/daily-learning/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://Pan-Binghong.github.io/daily-learning/favicon-32x32.png><link rel=apple-touch-icon href=https://Pan-Binghong.github.io/daily-learning/apple-touch-icon.png><link rel=mask-icon href=https://Pan-Binghong.github.io/daily-learning/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://Pan-Binghong.github.io/daily-learning/knowledge/llm%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%B7%A8%E5%85%A8/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><link rel=stylesheet href=https://unpkg.com/github-calendar@latest/dist/github-calendar-responsive.css><style>.reading-progress-bar{position:fixed;top:0;left:0;height:3px;background:linear-gradient(90deg,var(--primary),#00d4ff);z-index:9999;transition:width .1s ease;box-shadow:0 0 10px rgba(0,212,255,.5)}</style><script>document.addEventListener("DOMContentLoaded",function(){document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=document.querySelector(this.getAttribute("href"));t&&t.scrollIntoView({behavior:"smooth",block:"start"})})})})</script><meta property="og:url" content="https://Pan-Binghong.github.io/daily-learning/knowledge/llm%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%B7%A8%E5%85%A8/"><meta property="og:site_name" content="Pan Binghong's Tech Blog"><meta property="og:title" content="LLM调优方法|巨™全"><meta property="og:description" content=" 💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。
算效调优 硬件层面各个部件对大模型的优化策略
1. GPU加速 1.1 为什么GPU可以对大模型有加速效果? GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。
选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。
并行处理能力： 高吞吐量： 大规模计算： 优化的库和框架： 成本： 1.2 GPU里有什么,? Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：
CUDA Cores CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。
CUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。
Tensor Cores Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。
Tensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。
CUDA Cores&amp;Tensor Cores区别 应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。 计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。 性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。 CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。 1.3 主流GPU性能对比 1.4 训练/推理最佳配置 训练最优配置
推理最优配置"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="knowledge"><meta property="article:published_time" content="2024-11-16T13:01:00+00:00"><meta property="article:modified_time" content="2024-11-20T03:23:00+00:00"><meta property="article:tag" content="Knowledge"><meta name=twitter:card content="summary"><meta name=twitter:title content="LLM调优方法|巨™全"><meta name=twitter:description content="
💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。

算效调优
硬件层面各个部件对大模型的优化策略
1. GPU加速
1.1 为什么GPU可以对大模型有加速效果?
GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。

选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。

并行处理能力：
高吞吐量：
大规模计算：
优化的库和框架：
成本：

1.2 GPU里有什么,?
Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：
CUDA Cores
CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。
CUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。
Tensor Cores
Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。
Tensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。
CUDA Cores&amp;Tensor Cores区别

应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。
计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。
性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。
CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。

1.3 主流GPU性能对比

1.4 训练/推理最佳配置
训练最优配置

推理最优配置
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Knowledges","item":"https://Pan-Binghong.github.io/daily-learning/knowledge/"},{"@type":"ListItem","position":2,"name":"LLM调优方法|巨™全","item":"https://Pan-Binghong.github.io/daily-learning/knowledge/llm%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%B7%A8%E5%85%A8/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"LLM调优方法|巨™全","name":"LLM调优方法|巨™全","description":" 💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。\n算效调优 硬件层面各个部件对大模型的优化策略\n1. GPU加速 1.1 为什么GPU可以对大模型有加速效果? GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。\n选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。\n并行处理能力： 高吞吐量： 大规模计算： 优化的库和框架： 成本： 1.2 GPU里有什么,? Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：\nCUDA Cores CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。\nCUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。\nTensor Cores Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。\nTensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。\nCUDA Cores\u0026amp;Tensor Cores区别 应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。 计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。 性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。 CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。 1.3 主流GPU性能对比 1.4 训练/推理最佳配置 训练最优配置\n推理最优配置\n","keywords":["Knowledge"],"articleBody":" 💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。\n算效调优 硬件层面各个部件对大模型的优化策略\n1. GPU加速 1.1 为什么GPU可以对大模型有加速效果? GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。\n选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。\n并行处理能力： 高吞吐量： 大规模计算： 优化的库和框架： 成本： 1.2 GPU里有什么,? Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：\nCUDA Cores CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。\nCUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。\nTensor Cores Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。\nTensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。\nCUDA Cores\u0026Tensor Cores区别 应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。 计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。 性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。 CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。 1.3 主流GPU性能对比 1.4 训练/推理最佳配置 训练最优配置\n推理最优配置\n2. TPU/FPGA TPU（Tensor Processing Unit）和FPGA（Field-Programmable Gate Array）都是为加速机器学习任务而设计的专用硬件。\nTPU TPU是由Google开发的一种ASIC（Application-Specific Integrated Circuit），专门针对TensorFlow框架进行了优化。TPU的设计目标是在处理矩阵运算时提供更高的效率，这对于深度学习模型来说是非常关键的，因为它们通常包含大量的矩阵乘法操作。利用TPU可以实现以下优化：\n高效计算：TPU能够提供比传统CPU或GPU更高的浮点运算性能，在处理大规模神经网络时尤其有效。 低精度支持：TPU支持8位整数运算，这减少了数据传输量，加快了计算速度，同时降低了功耗。 分布式训练：通过构建TPU Pod，可以实现多个TPU之间的高效通信，从而支持更大规模的数据并行训练。 自动优化：TPU编译器可以自动将TensorFlow图转化为高效的TPU指令序列，减少了手动优化的需要。 FPGA FPGA是一种可编程逻辑器件，可以在硬件级别上根据特定的任务重新配置。这种灵活性使得FPGA非常适合于那些需要定制化处理流程的任务。对于大模型的优化，FPGA提供了如下优势：\n定制化：FPGA可以根据特定算法的需求进行编程，这意味着它可以针对特定的模型架构进行优化，达到最佳的性能。 低延迟：FPGA可以实现低延迟的数据处理，这对于实时应用非常重要。 能效比：相比于GPU，FPGA在某些任务上可以提供更好的能效比，尤其是在需要高并发且低功耗的场景下。 灵活性：FPGA可以在部署后进行重新配置，以适应新的算法或模型变化。 3. 内存带宽 提高内存带宽对于优化大模型的性能至关重要。大模型，特别是深度学习模型，通常包含数百万甚至数十亿的参数，这些参数在训练过程中需要频繁地被访问和更新。随着模型规模的增长，内存带宽成为了限制性能的一个重要因素，因为它直接影响到数据的加载和传输速度。\n3.1 内存带宽的重要性 内存带宽是指单位时间内可以从内存读取或写入的最大数据量。对于大模型而言，更高的内存带宽意味着模型可以更快地加载数据进行处理，进而提高计算效率。在大模型的训练过程中，内存带宽的不足会导致数据传输成为瓶颈，从而减慢训练速度。例如，在模型推理过程中，较大的内存缓存可以提高推理速度，但同时也减少了可用的上下文长度，需要在速度和上下文长度之间进行权衡。\n3.2 高速内存技术 AMD Fiji首款使用高带宽内存技术的图形处理器\n高速内存技术，如HBM（High Bandwidth Memory）和GDDR6。HBM通过垂直堆叠DRAM芯片来提供更高的带宽，而GDDR6则专为高性能图形处理单元（GPU）设计，能够提供比传统DDR内存更高的带宽。这些技术特别适用于处理大型数据集和复杂的神经网络模型，因为它们能更有效地支持大量数据的快速读取和写入。\n3.3 分布式设置中的网络连接 在分布式训练环境中，除了本地内存带宽之外，网络连接的质量也至关重要。快速的网络连接（如InfiniBand或RDMA over Converged Ethernet, RoCE）能够确保数据在多个计算节点间快速、高效地流动。例如，InfiniBand网络提供的带宽相较于其他网络技术有明显的优势，为解决AI大模型对服务器集群中每个GPU之间的高速、无缝通信的需求提供了支持。这对于跨多个节点同步模型参数和梯度更新尤为重要。\n提高内存带宽对于优化大模型的性能有着不可忽视的作用。通过采用高速内存技术和高效的网络连接方案，并结合合理的硬件选择和软件优化策略，可以有效克服内存带宽带来的瓶颈，从而加速大模型的训练和推理过程。\n4. 存储 4.1 传统存储方案 HDD(机械硬盘) SSD(固态硬盘) 4.2 高速存储方案 NVMe SSD(Non-Volatile Memory Express) NVMe SSD通过PCIe总线直接与CPU通信，利用闪存技术存储数据。NVMe协议旨在充分利用高速存储介质的特点，如低延迟和高I/O并行性。NVMe SSD提供了极高的带宽，因为PCIe接口比SATA或SAS接口提供了更高的带宽，使得数据传输速度更快。同时，由于减少了中间环节，NVMe SSD实现了更低的访问延迟。此外，NVMe支持多队列和多线程，允许多个读写操作同时进行，极大地提高了I/O性能。然而，NVMe SSD的成本较高，尤其是在高端产品中，并且需要特定的硬件支持，可能存在兼容性问题。 4.3 存储系统与大模型 对于大模型的训练和推理来说，存储系统的性能至关重要。HDD虽然在容量和成本上有优势，但由于其机械结构导致的访问速度慢和可靠性问题，已逐渐被SSD所取代。SSD提供了更快的读写速度和更高的可靠性，但在面对更高要求的应用场景时，如深度学习训练，NVMe SSD凭借其极高的带宽和低延迟特性成为了优选方案。尽管NVMe SSD的成本较高，但对于追求极致性能的应用来说，它是不可或缺的选择。在选择存储方案时，应根据实际需求权衡成本与性能之间的关系，以达到最优的效果。\n5. 冷却系统 5.1 风冷 风冷是最常见的数据中心冷却方法之一，它通过强制空气流动来带走设备产生的热量。这种方法相对简单且成本较低，适用于大多数常规服务器和硬件配置。风冷系统的核心组成部分包括风扇、过滤器和合理的气流管理。对于大模型的优化而言，风冷系统在训练初期阶段能够提供足够的冷却能力；然而，在处理更大、更复杂的模型时，风冷系统的局限性开始显现，尤其是在高密度部署的环境下，可能无法有效应对局部热点问题，导致硬件过热，影响计算效率和稳定性。\n5.2 液冷 液冷技术因其高效散热能力和更低的噪音水平而变得越来越受欢迎，主要分为直接接触液冷和间接液冷两种形式。直接接触液冷特别适用于高性能计算和深度学习训练，能够提供更高密度的冷却效果，帮助维持GPU和CPU等关键部件在一个稳定的温度范围内工作，从而确保训练过程的连续性和计算资源的有效利用。液冷还能减少因过热导致的硬件损坏风险，延长硬件寿命，对大模型的优化具有显著优势。\n5.3 热通道/冷通道分离 热通道/冷通道分离通过物理手段将机房内的气流分为冷通道和热通道两部分，前者专门为服务器提供冷空气，后者则收集热空气并将其引导至冷却设备或空调系统进行处理。这种设计可以显著减少混合冷热空气的情况，提高冷却系统的效能，减少能源消耗，并延长硬件使用寿命。对于大模型而言，热通道/冷通道分离有助于保持计算节点的温度稳定，确保训练过程中不会因为过热而导致性能下降或硬件故障，特别适合于分布式训练环境。\n6. 其他 6.1 高效电源供应设备 高效的电源供应设备对于优化大模型训练至关重要。80 Plus白金或钛金认证的电源供应器能够在不同负载条件下提供至少80%以上的效率，最高可达94%，显著减少能量转换过程中的损耗。数字电源管理技术通过实时调整电源输出，确保在各种负载条件下保持高效运作，从而实现更精细的能量管理，减少能源浪费。\n6.2 动态功耗管理技术 动态功耗管理技术如动态电压和频率调整（DVFS）可以根据实际负载动态调整CPU和GPU的电压和频率。在低负载时降低电压和频率可以大幅减少功耗，而在高负载时则可以迅速恢复性能。此外，智能休眠模式可以在无活动或低负载时将部分硬件单元暂时置于休眠状态，进一步节省能源，确保大模型训练过程中能源使用的高效性。\n6.3 不间断电源 (UPS) 和冗余设计 不间断电源（UPS）系统可以在电网供电中断时立即提供备用电源，确保系统不会因突然断电而停止运行，这对于长时间运行的大模型训练任务至关重要。冗余电源设计通过在关键硬件中部署冗余电源，确保即使其中一个电源故障，系统仍能继续运行，提高系统的可靠性和可用性。\n6.4 能源监测与管理 智能监控系统可以实时监测电源的使用情况，识别异常情况，并及时采取措施，例如调整负载分配以优化能源使用。自动化管理系统可以根据实际需求动态调整电源配置，在非高峰时段减少某些硬件的供电，在高峰期增加供电，确保能源使用的最大化效率，从而提高数据中心的整体能效比。\n输出效果调优 1. 优化数据 1.1 数据的重要性 大规模语言模型的开发依赖于广泛而多元的数据资源。研究文献详细阐述了人类在训练GPT-3模型时主要利用的数据源，这包括经筛选的CommonCrawl数据集、WebText2、Books1、Books2以及英文版Wikipedia等。例如，CommonCrawl的初始数据量高达45TB，筛选后仅剩570GB。通过分词技术处理上述资料，大约产生了5000亿个词元。为了确保模型能够利用高品质数据进行学习，GPT-3的训练过程中根据数据来源的差异调整了采样权重。在完成3000亿词元的训练量时，英文版Wikipedia的数据平均被循环利用了3.4次，而CommonCrawl和Books2的数据循环使用率分别仅为0.44次和0.43次。鉴于CommonCrawl数据集的筛选工作极为复杂，Meta公司的研究团队在训练OP模型时采纳了结合RoBERTa、Pile[68]以及PushShift.io Reddit数据的策略。考虑到这些数据集主要以英文为主，OPT模型也从CommonCrawl中提取了一部分非英文数据以丰富训练语料。大型语言模型所需的数据资源大致可分为通用数据和专业数据两类。通用数据涵盖了网页内容、图书、新闻报道、对话文本等，以其庞大的规模、多样性和易于获取的特点，为大型语言模型提供了基础的语言建模和泛化能力。而专业数据则包括多语言资料、科学文献、编程代码以及特定领域的专有信息等，这些在预训练阶段的引入，能够显著增强大型语言模型解决特定任务的能力。\n典型大语言模型所使用数量类型的分布\n1.2 数据回流方案 数据回流是指将模型生成的数据或预测结果重新引入到训练流程中，以此来更新模型。这种方法可以用于增强模型的学习能力，尤其是在面对那些随着时间变化而变化的数据集时。通过持续地将新产生的数据反馈给模型，可以让模型适应新的模式或纠正之前的偏差，从而提高其泛化能力和预测准确性。\n2. 调整超参数 调整超参数是指在训练模型之前选择一组最佳的参数值的过程，这些参数不是直接通过学习过程获得的。超参数包括学习率、批次大小、正则化系数等。合理的超参数设置对于模型的表现至关重要。通常，人们会采用网格搜索、随机搜索或贝叶斯优化等方法来进行超参数的优化，以找到能够最大化模型性能的一组超参数组合。\n3. 提示词工程 (Prompt Engineering) 提示词工程是指精心设计输入给模型的提示词，以便引导模型产生更符合期望的输出。这种技术特别适用于那些基于自然语言处理的大规模预训练模型。通过调整提示词的内容、结构以及语气，可以显著影响模型生成的结果。例如，在某些场景下，使用更正式的语言或提供更多的上下文信息可以促使模型生成更为准确和连贯的回答。提示词工程还可以用来控制生成内容的风格、语气甚至创造力水平。\n4. 检索增强生成(Retrieval-Augmented Generation, RAG) 检索增强生成是一种结合了检索技术和生成模型的方法，它允许模型在生成答案或内容时参考一个外部的知识库。这样做的好处是可以利用大量静态或动态的信息来增强生成的质量，特别是在处理那些需要精确信息或最新数据的任务时。RAG可以提升生成内容的相关性和准确性，尤其是在对话系统、问答系统或文本摘要等领域。\n5. 微调预训练模型 微调预训练模型是指在一个已经预先训练好的模型基础上，针对特定任务进一步训练模型的过程。预训练模型通常是在大规模数据上训练得到的，拥有良好的通用特征提取能力。通过在特定任务的小数据集上继续训练，可以使得模型更加专注于解决该任务，从而提升模型在特定领域或任务上的表现。\n微调各种尺寸大模型的硬件要求\n5.1 有监督微调(SFT) 在自然语言处理（NLP）领域，Supervised Finetuning（SFT）是一种至关重要的技术手段，用来提升大模型在某一特定领域的表现。通过精细的策划和实施，SFT 能够指导模型的学习过程，确保其学习成果与既定目标高度吻合。\nSFT 指的是，用户提供一份标注好的数据集，即，包含输入的 prompt 和预期输出的 response。然后，在已有的某个基座模型上继续调整参数，来达到和下游任务对齐的目的。\n5.1.1 什么时候需要用到SFT ? 通过提示词工程无法解决或提示词中描述过于复杂时。 对大模型输出内容有格式要求时，而模型仍有部分条件不符合要求。 期望通过 SFT 来减少 prompt 中的内容，加速线上推理的耗时。 5.1.2 SFT数据格式 每行一条JSON格式的数据：\nmessages (list, required): 描述一个对话列表。 role (str, required): 角色，system、user、assistant中的一个。 content (str, required): 对话内容文本。 loss_weight (float, optional): 对于内容的loss训练权重。当role=system/user，loss_weight默认值为0.0且不可修改；当role=assistant，loss_weight默认值为1.0。通过loss_weight字段，可以在训练数据中修改默认值。 5.1.3 SFT微调所需数据量级 模型中 SFT 的过程中，会学习 prompt 到 response 到映射关系，如果我们 SFT 的数据存在噪声（如错别字、错误格式、不符合预期输出的样本等），那么会对模型的训练过程造成比较严重的影响。因此，不可以一味去堆叠 SFT 的样本数量，样本的质量比数量更重要。\n针对不同场景下，数据量级的建议：\n文案生成，剧本创作，小说续写等生成类任务：2～3k。 参考问答：2k ~ 1w。 文本分类：1～3k，和类别数量以及任务难易度强相关，类别较多/任务较难的场景可能需要1w条以上。 5.2 LoRA微调 5.2.1 什么是LoRA ? LoRA（Low-Rank Adaptation of Large Language Models），直译为大语言模型的低阶自适应。LoRA 的基本原理是冻结预训练好的模型权重参数，在冻结原模型参数的情况下，通过往模型中加入额外的网络层，并只训练这些新增的网络层参数。由于这些新增参数数量较少，这样不仅 finetune 的成本显著下降，还能获得和全模型参数参与微调类似的效果。\n随着大语言模型的发展，模型的参数量越来越大，比如 GPT-3 参数量已经高达 1750 亿，因此，微调所有模型参数变得不可行。LoRA 微调方法由微软提出，通过只微调新增参数的方式，大大减少了下游任务的可训练参数数量。\n5.2.2 LoRA微调方法的基本原理 神经网络的每一层都包含矩阵的乘法。这些层中的权重矩阵通常具有满秩。当适应特定任务时，预训练语言模型具有低的 “内在维度”，将它们随机投影到更小的子空间时，它们仍然可以有效地学习。\n在大语言模型微调的过程中，LoRA 冻结了预先训练好的模型权重，并将可训练的秩的分解矩阵注入到 Transformer 体系结构的每一层。例如，对于预训练的权重矩阵W0，可以让其更新受到用低秩分解表示后者的约束：\n跟踪权重的变化而不是直接更新它们。 将大型权重矩阵分解为包含“可训练参数”的较小矩阵。 5.2.3 LoRA微调的优势 可训练参数显着减少，从而实现更快、更高效的微调。 保留原始的预训练权重，允许针对不同任务使用多个轻量级模型。 与其他参数高效方法兼容，可实现进一步优化。 在许多情况下，其性能可与完全微调的模型相媲美。 没有额外的推理延迟，因为适配器权重可以与基本模型合并。 5.2.4 QLoRA微调 QLoRa 通过量化可训练参数，用更少的位数表示它们，使 LORA 更进一步。这进一步减小了模型大小，有可能实现在内存和计算资源有限的设备上的部署。\n5.3 Freeze微调 Freeze 方法，即参数冻结，对原始模型部分参数进行冻结操作，仅训练部分参数，以达到在单卡或不进行 TP 或 PP 操作，就可以对大模型进行训练。在语言模型模型微调中，Freeze 微调方法仅微调 Transformer 后几层的全连接层参数，而冻结其它所有参数。\n5.4 GaLore微调 GaLore 是一种允许全参数学习的训练策略，但比常见的低秩自适应方法（例如 LoRA）更节省内存。GaLore 关键思想是利用权重矩阵 W 的梯度缓慢变化的低秩结构，而不是试图将权重矩阵直接近似为低秩形式。使得在消费级GPU上训练大型语言模型成为可能。这一策略为未来的大模型训练提供了重要的技术支持，具有广泛的应用前景。\n6. 代理(Agent) 增加辅助代理是指在主要模型之外引入其他小模型或组件，这些辅助代理可以帮助主模型更好地完成任务。辅助代理可能负责不同的子任务，如噪声过滤、特征增强、错误检测等，它们的工作成果可以作为额外的信息提供给主模型，从而帮助主模型做出更准确的决策。这种方法可以提高系统的鲁棒性和灵活性，使其在复杂环境中表现出色。\n模型结构 1. 模型深度与宽度的平衡 在语言模型中，增加模型的深度可以使其捕获更复杂的语言结构，而增加宽度则可以提供更多的表达能力。然而，深度和宽度的增加都会带来更高的计算成本和潜在的过拟合风险。可以通过实验来确定最优的层数和每层的隐藏单元数，找到一个既能提高模型性能又不会过度增加训练时间的平衡点。\n2. 残差连接 在语言模型中引入残差连接可以帮助模型更好地学习长期依赖关系，并减轻梯度消失的问题。通过让信息流绕过一层或多层，模型可以更容易地学习到输入与输出之间的映射关系。\n3. 注意力机制 在语言模型中使用自注意力机制，可以让模型学习到输入序列中不同位置之间的相关性。这种机制尤其适合处理变长的输入序列，因为它能够动态地为不同位置的词分配不同的权重。\n4. 多头注意力 通过将注意力机制分成多个头，每个头可以独立地关注输入的不同方面。这种方式能够增强模型对输入的多样性和复杂性的理解，从而提升整体性能。\n5. Transformer架构 即便不采用卷积，也可以使用基于注意力机制的Transformer架构来构建语言模型。这种架构通过完全依赖自注意力机制来处理序列数据，避免了传统RNN中顺序依赖的问题，并且能够并行化训练过程，加快训练速度。即便不采用卷积，也可以使用基于注意力机制的Transformer架构来构建语言模型。这种架构通过完全依赖自注意力机制来处理序列数据，避免了传统RNN中顺序依赖的问题，并且能够并行化训练过程，加快训练速度。\n6. 正则化技术 为了防止过拟合，可以在模型中加入正则化技术，比如Dropout，它通过在训练过程中随机关闭一部分神经元来提高模型的鲁棒性。此外，还可以使用权重衰减等其他形式的正则化来约束模型复杂度。\n应用于标准神经网络的Dropout\n7 混合专家(Mixture of Experts, MoE) 在语言模型中，MoE架构允许模型根据输入选择不同的专家来处理，从而在不增加太多参数的情况下提高模型的容量和表现力。这种方式特别适用于需要处理多种类型数据的语言任务。\nMoE架构的核心组件\n","wordCount":"337","inLanguage":"en","datePublished":"2024-11-16T13:01:00Z","dateModified":"2024-11-20T03:23:00Z","author":{"@type":"Person","name":"Pan Binghong"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://Pan-Binghong.github.io/daily-learning/knowledge/llm%E8%B0%83%E4%BC%98%E6%96%B9%E6%B3%95%E5%B7%A8%E5%85%A8/"},"publisher":{"@type":"Organization","name":"Pan Binghong's Tech Blog","logo":{"@type":"ImageObject","url":"https://Pan-Binghong.github.io/daily-learning/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://Pan-Binghong.github.io/daily-learning/ accesskey=h title="Pan Binghong's Tech Blog (Alt + H)">Pan Binghong's Tech Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://Pan-Binghong.github.io/daily-learning/ title="🏠 首页"><span>🏠 首页</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/ai/ title="🤖 AI"><span>🤖 AI</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/knowledge/ title="📚 知识库"><span>📚 知识库</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/backend/ title="⚙️ 后端"><span>⚙️ 后端</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/devops/ title="🔧 DevOps"><span>🔧 DevOps</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/other/ title="📝 其他"><span>📝 其他</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/search/ title="🔍 搜索"><span>🔍 搜索</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/tags/ title="🏷️ 标签"><span>🏷️ 标签</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/archives/ title="📂 归档"><span>📂 归档</span></a></li><li><a href=https://Pan-Binghong.github.io/daily-learning/about/ title="👤 关于"><span>👤 关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://Pan-Binghong.github.io/daily-learning/>Home</a>&nbsp;»&nbsp;<a href=https://Pan-Binghong.github.io/daily-learning/knowledge/>Knowledges</a></div><h1 class="post-title entry-hint-parent">LLM调优方法|巨™全</h1><div class=post-meta><span title='2024-11-16 13:01:00 +0000 UTC'>November 16, 2024</span>&nbsp;·&nbsp;<span>2 min</span>&nbsp;·&nbsp;<span>337 words</span>&nbsp;·&nbsp;<span>Pan Binghong</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e7%ae%97%e6%95%88%e8%b0%83%e4%bc%98 aria-label=算效调优>算效调优</a><ul><li><a href=#1-gpu%e5%8a%a0%e9%80%9f aria-label="1. GPU加速">1. GPU加速</a></li><li><a href=#11-%e4%b8%ba%e4%bb%80%e4%b9%88gpu%e5%8f%af%e4%bb%a5%e5%af%b9%e5%a4%a7%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%8a%a0%e9%80%9f%e6%95%88%e6%9e%9c aria-label="1.1 为什么GPU可以对大模型有加速效果?">1.1 为什么GPU可以对大模型有加速效果?</a></li><li><a href=#12-gpu%e9%87%8c%e6%9c%89%e4%bb%80%e4%b9%88 aria-label="1.2 GPU里有什么,?">1.2 GPU里有什么,?</a></li><li><a href=#cuda-cores aria-label="CUDA Cores">CUDA Cores</a></li><li><a href=#tensor-cores aria-label="Tensor Cores">Tensor Cores</a></li><li><a href=#cuda-corestensor-cores%e5%8c%ba%e5%88%ab aria-label="CUDA Cores&amp;Tensor Cores区别">CUDA Cores&amp;Tensor Cores区别</a></li><li><a href=#13-%e4%b8%bb%e6%b5%81gpu%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94 aria-label="1.3 主流GPU性能对比">1.3 主流GPU性能对比</a></li><li><a href=#14-%e8%ae%ad%e7%bb%83%e6%8e%a8%e7%90%86%e6%9c%80%e4%bd%b3%e9%85%8d%e7%bd%ae aria-label="1.4 训练/推理最佳配置">1.4 训练/推理最佳配置</a></li><li><a href=#2-tpufpga aria-label="2. TPU/FPGA">2. TPU/FPGA</a></li><li><a href=#tpu aria-label=TPU>TPU</a></li><li><a href=#fpga aria-label=FPGA>FPGA</a></li><li><a href=#3-%e5%86%85%e5%ad%98%e5%b8%a6%e5%ae%bd aria-label="3. 内存带宽">3. 内存带宽</a></li><li><a href=#31-%e5%86%85%e5%ad%98%e5%b8%a6%e5%ae%bd%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7 aria-label="3.1 内存带宽的重要性">3.1 内存带宽的重要性</a></li><li><a href=#32-%e9%ab%98%e9%80%9f%e5%86%85%e5%ad%98%e6%8a%80%e6%9c%af aria-label="3.2 高速内存技术">3.2 高速内存技术</a></li><li><a href=#33-%e5%88%86%e5%b8%83%e5%bc%8f%e8%ae%be%e7%bd%ae%e4%b8%ad%e7%9a%84%e7%bd%91%e7%bb%9c%e8%bf%9e%e6%8e%a5 aria-label="3.3 分布式设置中的网络连接">3.3 分布式设置中的网络连接</a></li><li><a href=#4-%e5%ad%98%e5%82%a8 aria-label="4. 存储">4. 存储</a></li><li><a href=#41-%e4%bc%a0%e7%bb%9f%e5%ad%98%e5%82%a8%e6%96%b9%e6%a1%88 aria-label="4.1 传统存储方案">4.1 传统存储方案</a></li><li><a href=#42-%e9%ab%98%e9%80%9f%e5%ad%98%e5%82%a8%e6%96%b9%e6%a1%88 aria-label="4.2 高速存储方案">4.2 高速存储方案</a></li><li><a href=#43-%e5%ad%98%e5%82%a8%e7%b3%bb%e7%bb%9f%e4%b8%8e%e5%a4%a7%e6%a8%a1%e5%9e%8b aria-label="4.3 存储系统与大模型">4.3 存储系统与大模型</a></li><li><a href=#5-%e5%86%b7%e5%8d%b4%e7%b3%bb%e7%bb%9f aria-label="5. 冷却系统">5. 冷却系统</a></li><li><a href=#51-%e9%a3%8e%e5%86%b7 aria-label="5.1 风冷">5.1 风冷</a></li><li><a href=#52-%e6%b6%b2%e5%86%b7 aria-label="5.2 液冷">5.2 液冷</a></li><li><a href=#53-%e7%83%ad%e9%80%9a%e9%81%93%e5%86%b7%e9%80%9a%e9%81%93%e5%88%86%e7%a6%bb aria-label="5.3 热通道/冷通道分离">5.3 热通道/冷通道分离</a></li><li><a href=#6-%e5%85%b6%e4%bb%96 aria-label="6. 其他">6. 其他</a></li><li><a href=#61-%e9%ab%98%e6%95%88%e7%94%b5%e6%ba%90%e4%be%9b%e5%ba%94%e8%ae%be%e5%a4%87 aria-label="6.1 高效电源供应设备">6.1 高效电源供应设备</a></li><li><a href=#62-%e5%8a%a8%e6%80%81%e5%8a%9f%e8%80%97%e7%ae%a1%e7%90%86%e6%8a%80%e6%9c%af aria-label="6.2 动态功耗管理技术">6.2 动态功耗管理技术</a></li><li><a href=#63-%e4%b8%8d%e9%97%b4%e6%96%ad%e7%94%b5%e6%ba%90-ups-%e5%92%8c%e5%86%97%e4%bd%99%e8%ae%be%e8%ae%a1 aria-label="6.3 不间断电源 (UPS) 和冗余设计">6.3 不间断电源 (UPS) 和冗余设计</a></li><li><a href=#64-%e8%83%bd%e6%ba%90%e7%9b%91%e6%b5%8b%e4%b8%8e%e7%ae%a1%e7%90%86 aria-label="6.4 能源监测与管理">6.4 能源监测与管理</a></li></ul></li><li><a href=#%e8%be%93%e5%87%ba%e6%95%88%e6%9e%9c%e8%b0%83%e4%bc%98 aria-label=输出效果调优>输出效果调优</a><ul><li><a href=#1-%e4%bc%98%e5%8c%96%e6%95%b0%e6%8d%ae aria-label="1. 优化数据">1. 优化数据</a></li><li><a href=#11-%e6%95%b0%e6%8d%ae%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7 aria-label="1.1 数据的重要性">1.1 数据的重要性</a></li><li><a href=#12-%e6%95%b0%e6%8d%ae%e5%9b%9e%e6%b5%81%e6%96%b9%e6%a1%88 aria-label="1.2 数据回流方案">1.2 数据回流方案</a></li><li><a href=#2-%e8%b0%83%e6%95%b4%e8%b6%85%e5%8f%82%e6%95%b0 aria-label="2. 调整超参数">2. 调整超参数</a></li><li><a href=#3-%e6%8f%90%e7%a4%ba%e8%af%8d%e5%b7%a5%e7%a8%8b-prompt-engineering aria-label="3. 提示词工程 (Prompt Engineering)">3. 提示词工程 (Prompt Engineering)</a></li><li><a href=#4-%e6%a3%80%e7%b4%a2%e5%a2%9e%e5%bc%ba%e7%94%9f%e6%88%90retrieval-augmented-generation-rag aria-label="4. 检索增强生成(Retrieval-Augmented Generation, RAG)">4. 检索增强生成(Retrieval-Augmented Generation, RAG)</a></li><li><a href=#5-%e5%be%ae%e8%b0%83%e9%a2%84%e8%ae%ad%e7%bb%83%e6%a8%a1%e5%9e%8b aria-label="5. 微调预训练模型">5. 微调预训练模型</a></li><li><a href=#51-%e6%9c%89%e7%9b%91%e7%9d%a3%e5%be%ae%e8%b0%83sft aria-label="5.1 有监督微调(SFT)">5.1 有监督微调(SFT)</a></li><li><a href=#511-%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%9c%80%e8%a6%81%e7%94%a8%e5%88%b0sft- aria-label="5.1.1 什么时候需要用到SFT ?">5.1.1 什么时候需要用到SFT ?</a></li><li><a href=#512-sft%e6%95%b0%e6%8d%ae%e6%a0%bc%e5%bc%8f aria-label="5.1.2 SFT数据格式">5.1.2 SFT数据格式</a></li><li><a href=#513-sft%e5%be%ae%e8%b0%83%e6%89%80%e9%9c%80%e6%95%b0%e6%8d%ae%e9%87%8f%e7%ba%a7 aria-label="5.1.3 SFT微调所需数据量级">5.1.3 SFT微调所需数据量级</a></li><li><a href=#52-lora%e5%be%ae%e8%b0%83 aria-label="5.2 LoRA微调">5.2 LoRA微调</a></li><li><a href=#521-%e4%bb%80%e4%b9%88%e6%98%aflora- aria-label="5.2.1 什么是LoRA ?">5.2.1 什么是LoRA ?</a></li><li><a href=#522-lora%e5%be%ae%e8%b0%83%e6%96%b9%e6%b3%95%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%8e%9f%e7%90%86 aria-label="5.2.2 LoRA微调方法的基本原理">5.2.2 LoRA微调方法的基本原理</a></li><li><a href=#523-lora%e5%be%ae%e8%b0%83%e7%9a%84%e4%bc%98%e5%8a%bf aria-label="5.2.3 LoRA微调的优势">5.2.3 LoRA微调的优势</a></li><li><a href=#524-qlora%e5%be%ae%e8%b0%83 aria-label="5.2.4 QLoRA微调">5.2.4 QLoRA微调</a></li><li><a href=#53-freeze%e5%be%ae%e8%b0%83 aria-label="5.3 Freeze微调">5.3 Freeze微调</a></li><li><a href=#54-galore%e5%be%ae%e8%b0%83 aria-label="5.4 GaLore微调">5.4 GaLore微调</a></li><li><a href=#6-%e4%bb%a3%e7%90%86agent aria-label="6. 代理(Agent)">6. 代理(Agent)</a></li></ul></li><li><a href=#%e6%a8%a1%e5%9e%8b%e7%bb%93%e6%9e%84 aria-label=模型结构>模型结构</a><ul><li><a href=#1-%e6%a8%a1%e5%9e%8b%e6%b7%b1%e5%ba%a6%e4%b8%8e%e5%ae%bd%e5%ba%a6%e7%9a%84%e5%b9%b3%e8%a1%a1 aria-label="1. 模型深度与宽度的平衡">1. 模型深度与宽度的平衡</a></li><li><a href=#2-%e6%ae%8b%e5%b7%ae%e8%bf%9e%e6%8e%a5 aria-label="2. 残差连接">2. 残差连接</a></li><li><a href=#3-%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6 aria-label="3. 注意力机制">3. 注意力机制</a></li><li><a href=#4-%e5%a4%9a%e5%a4%b4%e6%b3%a8%e6%84%8f%e5%8a%9b aria-label="4. 多头注意力">4. 多头注意力</a></li><li><a href=#5-transformer%e6%9e%b6%e6%9e%84 aria-label="5. Transformer架构">5. Transformer架构</a></li><li><a href=#6-%e6%ad%a3%e5%88%99%e5%8c%96%e6%8a%80%e6%9c%af aria-label="6. 正则化技术">6. 正则化技术</a></li><li><a href=#7-%e6%b7%b7%e5%90%88%e4%b8%93%e5%ae%b6mixture-of-experts-moe aria-label="7 混合专家(Mixture of Experts, MoE)">7 混合专家(Mixture of Experts, MoE)</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>💡 大语言模型调优方案, 涉及计算效能调优, 推理效果调优, 模型结构调优。</p></blockquote><h2 id=算效调优>算效调优<a hidden class=anchor aria-hidden=true href=#算效调优>#</a></h2><p>硬件层面各个部件对大模型的优化策略</p><h3 id=1-gpu加速>1. GPU加速<a hidden class=anchor aria-hidden=true href=#1-gpu加速>#</a></h3><h3 id=11-为什么gpu可以对大模型有加速效果>1.1 为什么GPU可以对大模型有加速效果?<a hidden class=anchor aria-hidden=true href=#11-为什么gpu可以对大模型有加速效果>#</a></h3><p>GPU的核心优势在于其并行处理能力，可以同时执行成千上万的计算任务。对于深度学习模型而言，这意味着可以并行处理大量的矩阵乘法和向量运算，这些是模型训练的核心。GPU的计算能力通常以TFLOPS（每秒万亿次浮点运算）来衡量。高TFLOPS值意味着GPU能够在较短的时间内完成更多的计算任务，从而加快模型的训练速度。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/1f817137-5537-4e3f-a5ad-88385208183c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=afbe6a1530b1d9a209820143c8c450fea2681a18de089293019113218550ba38&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>选择GPU而非CPU进行大模型训练的主要原因是因为GPU在并行处理能力、高吞吐量和针对机器学习任务的优化方面的优势。这使得GPU成为训练复杂和大规模机器学习模型的首选。</p><ul><li>并行处理能力：</li><li>高吞吐量：</li><li>大规模计算：</li><li>优化的库和框架：</li><li>成本：</li></ul><h3 id=12-gpu里有什么>1.2 GPU里有什么,?<a hidden class=anchor aria-hidden=true href=#12-gpu里有什么>#</a></h3><p>Tensor Cores和CUDA Cores都是NVIDIA GPU架构中的关键组成部分，但它们的设计目标和服务的对象有所不同。下面详细介绍这两种核心的区别：</p><h3 id=cuda-cores>CUDA Cores<a hidden class=anchor aria-hidden=true href=#cuda-cores>#</a></h3><p>CUDA Cores是NVIDIA GPU中的基础计算单元，类似于CPU中的核心，但专门为并行计算而优化。CUDA Cores能够执行各种类型的数学运算，包括整数运算、单精度浮点运算以及双精度浮点运算。CUDA Cores的数量决定了GPU的并行计算能力，更多的CUDA Cores意味着更强的并行处理能力。</p><p>CUDA Cores被设计为一种通用的计算资源，可以用于执行广泛的任务，从简单的图形渲染到复杂的科学计算，甚至是深度学习模型的训练。CUDA Cores支持通过CUDA编程接口直接访问，使得开发人员能够编写高效的并行计算代码。</p><h3 id=tensor-cores>Tensor Cores<a hidden class=anchor aria-hidden=true href=#tensor-cores>#</a></h3><p>Tensor Cores是NVIDIA为加速深度学习任务而专门设计的一种新型计算单元。它们最早出现在2017年的Volta架构中，并随后在Turing、Ampere等架构中得到了发展和完善。Tensor Cores的主要特点是它们特别适合执行深度学习所需的矩阵运算，如矩阵乘法和累积运算。</p><p>Tensor Cores的一个重要特性是它们支持混合精度计算，即能够在FP16（半精度浮点数）和TF32（Tensor Float-32）之间进行切换，从而提供更高的计算效率和能效比。此外，Tensor Cores还能在每个时钟周期内执行多项操作，相比之下，传统的CUDA Cores在每个时钟周期只能执行单一操作。</p><h3 id=cuda-corestensor-cores区别>CUDA Cores&amp;Tensor Cores区别<a hidden class=anchor aria-hidden=true href=#cuda-corestensor-cores区别>#</a></h3><ol><li>应用场景：CUDA Cores是通用的并行计算单元，可以处理各种计算任务；而Tensor Cores则专门针对深度学习中的矩阵运算进行了优化。</li><li>计算精度：CUDA Cores支持更广泛的精度计算，包括FP64、FP32和INT32等；Tensor Cores则专注于半精度浮点数（FP16）和混合精度计算（如TF32）。</li><li>性能：在处理深度学习相关的矩阵运算时，Tensor Cores相比CUDA Cores能够提供更高的性能和能效比。
CUDA Cores提供了广泛的计算灵活性，而Tensor Cores则是在特定任务上（如深度学习）实现了性能的飞跃。这两种核心的组合使得现代GPU既能满足传统计算需求，也能适应日益增长的人工智能计算需求。</li></ol><h3 id=13-主流gpu性能对比>1.3 主流GPU性能对比<a hidden class=anchor aria-hidden=true href=#13-主流gpu性能对比>#</a></h3><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/a8cc3e56-2481-4af0-a732-a8a0d0ea3be5/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=5998f1bc584866887d267197924c07b86118d9fe4371a948412ff81e26687199&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=14-训练推理最佳配置>1.4 训练/推理最佳配置<a hidden class=anchor aria-hidden=true href=#14-训练推理最佳配置>#</a></h3><p>训练最优配置</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/cf3c59f0-3606-42b7-984c-27d0284524a9/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=28f4dfda48371f027b0b4b15c28e42cb421441403735c563b64fc6925963b985&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>推理最优配置</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/039953db-cdb8-4998-823b-f4135b2d58b2/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=0815a4d3db6f590885444b93f2d8595ec8747ae5011871adde7768ad395b4ce8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=2-tpufpga>2. TPU/FPGA<a hidden class=anchor aria-hidden=true href=#2-tpufpga>#</a></h3><p>TPU（Tensor Processing Unit）和FPGA（Field-Programmable Gate Array）都是为加速机器学习任务而设计的专用硬件。</p><h3 id=tpu>TPU<a hidden class=anchor aria-hidden=true href=#tpu>#</a></h3><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/314d0bea-1218-4b1d-bdef-522519ea6c39/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=1adf4b86a27d2f727ba839ff502eb24383ca59a8c0ad2e4ffd15386d5dd25f85&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>TPU是由Google开发的一种ASIC（Application-Specific Integrated Circuit），专门针对TensorFlow框架进行了优化。TPU的设计目标是在处理矩阵运算时提供更高的效率，这对于深度学习模型来说是非常关键的，因为它们通常包含大量的矩阵乘法操作。利用TPU可以实现以下优化：</p><ul><li>高效计算：TPU能够提供比传统CPU或GPU更高的浮点运算性能，在处理大规模神经网络时尤其有效。</li><li>低精度支持：TPU支持8位整数运算，这减少了数据传输量，加快了计算速度，同时降低了功耗。</li><li>分布式训练：通过构建TPU Pod，可以实现多个TPU之间的高效通信，从而支持更大规模的数据并行训练。</li><li>自动优化：TPU编译器可以自动将TensorFlow图转化为高效的TPU指令序列，减少了手动优化的需要。</li></ul><h3 id=fpga>FPGA<a hidden class=anchor aria-hidden=true href=#fpga>#</a></h3><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/d09b5a5a-14cb-4b82-bc3e-8d3879691154/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025251Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=6b678c2e3ee96c69b96384c11fc0bef763ec9f2d91a6f5361966f018fa1f4230&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>FPGA是一种可编程逻辑器件，可以在硬件级别上根据特定的任务重新配置。这种灵活性使得FPGA非常适合于那些需要定制化处理流程的任务。对于大模型的优化，FPGA提供了如下优势：</p><ul><li>定制化：FPGA可以根据特定算法的需求进行编程，这意味着它可以针对特定的模型架构进行优化，达到最佳的性能。</li><li>低延迟：FPGA可以实现低延迟的数据处理，这对于实时应用非常重要。</li><li>能效比：相比于GPU，FPGA在某些任务上可以提供更好的能效比，尤其是在需要高并发且低功耗的场景下。</li><li>灵活性：FPGA可以在部署后进行重新配置，以适应新的算法或模型变化。</li></ul><h3 id=3-内存带宽>3. 内存带宽<a hidden class=anchor aria-hidden=true href=#3-内存带宽>#</a></h3><p>提高内存带宽对于优化大模型的性能至关重要。大模型，特别是深度学习模型，通常包含数百万甚至数十亿的参数，这些参数在训练过程中需要频繁地被访问和更新。随着模型规模的增长，内存带宽成为了限制性能的一个重要因素，因为它直接影响到数据的加载和传输速度。</p><h3 id=31-内存带宽的重要性>3.1 内存带宽的重要性<a hidden class=anchor aria-hidden=true href=#31-内存带宽的重要性>#</a></h3><p>内存带宽是指单位时间内可以从内存读取或写入的最大数据量。对于大模型而言，更高的内存带宽意味着模型可以更快地加载数据进行处理，进而提高计算效率。在大模型的训练过程中，内存带宽的不足会导致数据传输成为瓶颈，从而减慢训练速度。例如，在模型推理过程中，较大的内存缓存可以提高推理速度，但同时也减少了可用的上下文长度，需要在速度和上下文长度之间进行权衡。</p><h3 id=32-高速内存技术>3.2 高速内存技术<a hidden class=anchor aria-hidden=true href=#32-高速内存技术>#</a></h3><p>AMD Fiji首款使用高带宽内存技术的图形处理器</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/2e46ca9a-e9d5-43be-8245-7b4661e8858d/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=2f3b774e01cc5c23f07347acb1b53ef273b22e3e42bc24a4631e3036147e37a6&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>高速内存技术，如HBM（High Bandwidth Memory）和GDDR6。HBM通过垂直堆叠DRAM芯片来提供更高的带宽，而GDDR6则专为高性能图形处理单元（GPU）设计，能够提供比传统DDR内存更高的带宽。这些技术特别适用于处理大型数据集和复杂的神经网络模型，因为它们能更有效地支持大量数据的快速读取和写入。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/eff0cf08-2bb1-4f72-a258-a3a76887b0d1/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=0aa982e5718fd92235d5c4a5a10a35d7f1b74cb579a55f220b820be676be0603&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/0e014e95-dd34-493a-bb6a-69a1ddef79de/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=576cf35647bc42ed169e4b09831c4391bb63a20b9c2b8b724d11fdedccfb2ac6&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=33-分布式设置中的网络连接>3.3 分布式设置中的网络连接<a hidden class=anchor aria-hidden=true href=#33-分布式设置中的网络连接>#</a></h3><p>在分布式训练环境中，除了本地内存带宽之外，网络连接的质量也至关重要。快速的网络连接（如InfiniBand或RDMA over Converged Ethernet, RoCE）能够确保数据在多个计算节点间快速、高效地流动。例如，InfiniBand网络提供的带宽相较于其他网络技术有明显的优势，为解决AI大模型对服务器集群中每个GPU之间的高速、无缝通信的需求提供了支持。这对于跨多个节点同步模型参数和梯度更新尤为重要。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/6ca8b8f3-5d57-4487-8a28-3311eba87280/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=6178714a896293f37d36bee4a7bf6be417da2d1828e5446695899b43771ffeb7&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>提高内存带宽对于优化大模型的性能有着不可忽视的作用。通过采用高速内存技术和高效的网络连接方案，并结合合理的硬件选择和软件优化策略，可以有效克服内存带宽带来的瓶颈，从而加速大模型的训练和推理过程。</p><h3 id=4-存储>4. 存储<a hidden class=anchor aria-hidden=true href=#4-存储>#</a></h3><h3 id=41-传统存储方案>4.1 传统存储方案<a hidden class=anchor aria-hidden=true href=#41-传统存储方案>#</a></h3><ul><li>HDD(机械硬盘)</li><li>SSD(固态硬盘)</li></ul><h3 id=42-高速存储方案>4.2 高速存储方案<a hidden class=anchor aria-hidden=true href=#42-高速存储方案>#</a></h3><ul><li>NVMe SSD(Non-Volatile Memory Express)
NVMe SSD通过PCIe总线直接与CPU通信，利用闪存技术存储数据。NVMe协议旨在充分利用高速存储介质的特点，如低延迟和高I/O并行性。NVMe SSD提供了极高的带宽，因为PCIe接口比SATA或SAS接口提供了更高的带宽，使得数据传输速度更快。同时，由于减少了中间环节，NVMe SSD实现了更低的访问延迟。此外，NVMe支持多队列和多线程，允许多个读写操作同时进行，极大地提高了I/O性能。然而，NVMe SSD的成本较高，尤其是在高端产品中，并且需要特定的硬件支持，可能存在兼容性问题。</li></ul><h3 id=43-存储系统与大模型>4.3 存储系统与大模型<a hidden class=anchor aria-hidden=true href=#43-存储系统与大模型>#</a></h3><p>对于大模型的训练和推理来说，存储系统的性能至关重要。HDD虽然在容量和成本上有优势，但由于其机械结构导致的访问速度慢和可靠性问题，已逐渐被SSD所取代。SSD提供了更快的读写速度和更高的可靠性，但在面对更高要求的应用场景时，如深度学习训练，NVMe SSD凭借其极高的带宽和低延迟特性成为了优选方案。尽管NVMe SSD的成本较高，但对于追求极致性能的应用来说，它是不可或缺的选择。在选择存储方案时，应根据实际需求权衡成本与性能之间的关系，以达到最优的效果。</p><h3 id=5-冷却系统>5. 冷却系统<a hidden class=anchor aria-hidden=true href=#5-冷却系统>#</a></h3><h3 id=51-风冷>5.1 风冷<a hidden class=anchor aria-hidden=true href=#51-风冷>#</a></h3><p>风冷是最常见的数据中心冷却方法之一，它通过强制空气流动来带走设备产生的热量。这种方法相对简单且成本较低，适用于大多数常规服务器和硬件配置。风冷系统的核心组成部分包括风扇、过滤器和合理的气流管理。对于大模型的优化而言，风冷系统在训练初期阶段能够提供足够的冷却能力；然而，在处理更大、更复杂的模型时，风冷系统的局限性开始显现，尤其是在高密度部署的环境下，可能无法有效应对局部热点问题，导致硬件过热，影响计算效率和稳定性。</p><h3 id=52-液冷>5.2 液冷<a hidden class=anchor aria-hidden=true href=#52-液冷>#</a></h3><p>液冷技术因其高效散热能力和更低的噪音水平而变得越来越受欢迎，主要分为直接接触液冷和间接液冷两种形式。直接接触液冷特别适用于高性能计算和深度学习训练，能够提供更高密度的冷却效果，帮助维持GPU和CPU等关键部件在一个稳定的温度范围内工作，从而确保训练过程的连续性和计算资源的有效利用。液冷还能减少因过热导致的硬件损坏风险，延长硬件寿命，对大模型的优化具有显著优势。</p><h3 id=53-热通道冷通道分离>5.3 热通道/冷通道分离<a hidden class=anchor aria-hidden=true href=#53-热通道冷通道分离>#</a></h3><p>热通道/冷通道分离通过物理手段将机房内的气流分为冷通道和热通道两部分，前者专门为服务器提供冷空气，后者则收集热空气并将其引导至冷却设备或空调系统进行处理。这种设计可以显著减少混合冷热空气的情况，提高冷却系统的效能，减少能源消耗，并延长硬件使用寿命。对于大模型而言，热通道/冷通道分离有助于保持计算节点的温度稳定，确保训练过程中不会因为过热而导致性能下降或硬件故障，特别适合于分布式训练环境。</p><h3 id=6-其他>6. 其他<a hidden class=anchor aria-hidden=true href=#6-其他>#</a></h3><h3 id=61-高效电源供应设备>6.1 高效电源供应设备<a hidden class=anchor aria-hidden=true href=#61-高效电源供应设备>#</a></h3><p>高效的电源供应设备对于优化大模型训练至关重要。80 Plus白金或钛金认证的电源供应器能够在不同负载条件下提供至少80%以上的效率，最高可达94%，显著减少能量转换过程中的损耗。数字电源管理技术通过实时调整电源输出，确保在各种负载条件下保持高效运作，从而实现更精细的能量管理，减少能源浪费。</p><h3 id=62-动态功耗管理技术>6.2 动态功耗管理技术<a hidden class=anchor aria-hidden=true href=#62-动态功耗管理技术>#</a></h3><p>动态功耗管理技术如动态电压和频率调整（DVFS）可以根据实际负载动态调整CPU和GPU的电压和频率。在低负载时降低电压和频率可以大幅减少功耗，而在高负载时则可以迅速恢复性能。此外，智能休眠模式可以在无活动或低负载时将部分硬件单元暂时置于休眠状态，进一步节省能源，确保大模型训练过程中能源使用的高效性。</p><h3 id=63-不间断电源-ups-和冗余设计>6.3 不间断电源 (UPS) 和冗余设计<a hidden class=anchor aria-hidden=true href=#63-不间断电源-ups-和冗余设计>#</a></h3><p>不间断电源（UPS）系统可以在电网供电中断时立即提供备用电源，确保系统不会因突然断电而停止运行，这对于长时间运行的大模型训练任务至关重要。冗余电源设计通过在关键硬件中部署冗余电源，确保即使其中一个电源故障，系统仍能继续运行，提高系统的可靠性和可用性。</p><h3 id=64-能源监测与管理>6.4 能源监测与管理<a hidden class=anchor aria-hidden=true href=#64-能源监测与管理>#</a></h3><p>智能监控系统可以实时监测电源的使用情况，识别异常情况，并及时采取措施，例如调整负载分配以优化能源使用。自动化管理系统可以根据实际需求动态调整电源配置，在非高峰时段减少某些硬件的供电，在高峰期增加供电，确保能源使用的最大化效率，从而提高数据中心的整体能效比。</p><hr><h2 id=输出效果调优>输出效果调优<a hidden class=anchor aria-hidden=true href=#输出效果调优>#</a></h2><h3 id=1-优化数据>1. 优化数据<a hidden class=anchor aria-hidden=true href=#1-优化数据>#</a></h3><h3 id=11-数据的重要性>1.1 数据的重要性<a hidden class=anchor aria-hidden=true href=#11-数据的重要性>#</a></h3><p>大规模语言模型的开发依赖于广泛而多元的数据资源。研究文献详细阐述了人类在训练GPT-3模型时主要利用的数据源，这包括经筛选的CommonCrawl数据集、WebText2、Books1、Books2以及英文版Wikipedia等。例如，CommonCrawl的初始数据量高达45TB，筛选后仅剩570GB。通过分词技术处理上述资料，大约产生了5000亿个词元。为了确保模型能够利用高品质数据进行学习，GPT-3的训练过程中根据数据来源的差异调整了采样权重。在完成3000亿词元的训练量时，英文版Wikipedia的数据平均被循环利用了3.4次，而CommonCrawl和Books2的数据循环使用率分别仅为0.44次和0.43次。鉴于CommonCrawl数据集的筛选工作极为复杂，Meta公司的研究团队在训练OP模型时采纳了结合RoBERTa、Pile[68]以及PushShift.io Reddit数据的策略。考虑到这些数据集主要以英文为主，OPT模型也从CommonCrawl中提取了一部分非英文数据以丰富训练语料。大型语言模型所需的数据资源大致可分为通用数据和专业数据两类。通用数据涵盖了网页内容、图书、新闻报道、对话文本等，以其庞大的规模、多样性和易于获取的特点，为大型语言模型提供了基础的语言建模和泛化能力。而专业数据则包括多语言资料、科学文献、编程代码以及特定领域的专有信息等，这些在预训练阶段的引入，能够显著增强大型语言模型解决特定任务的能力。</p><p>典型大语言模型所使用数量类型的分布</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/c8d9a4d5-259e-4156-985a-3c53c36ac6cd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=bf91f2851b154241682515c0b41754aa9475e2cab81d5c875207411444fcec55&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=12-数据回流方案>1.2 数据回流方案<a hidden class=anchor aria-hidden=true href=#12-数据回流方案>#</a></h3><p>数据回流是指将模型生成的数据或预测结果重新引入到训练流程中，以此来更新模型。这种方法可以用于增强模型的学习能力，尤其是在面对那些随着时间变化而变化的数据集时。通过持续地将新产生的数据反馈给模型，可以让模型适应新的模式或纠正之前的偏差，从而提高其泛化能力和预测准确性。</p><h3 id=2-调整超参数>2. 调整超参数<a hidden class=anchor aria-hidden=true href=#2-调整超参数>#</a></h3><p>调整超参数是指在训练模型之前选择一组最佳的参数值的过程，这些参数不是直接通过学习过程获得的。超参数包括学习率、批次大小、正则化系数等。合理的超参数设置对于模型的表现至关重要。通常，人们会采用网格搜索、随机搜索或贝叶斯优化等方法来进行超参数的优化，以找到能够最大化模型性能的一组超参数组合。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/019acd31-7415-4c83-af39-778aabf9d03b/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4662OPUC7XU%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJHMEUCIQCKQ6wvz7Qzca%2FCyPXkzEYLhiA%2FAYyuCqkTFgH2VS8KBQIgOJ1FBb5W0tkWRdJ4cqoNjghKSR2yW2iuzUSQKeaRZlkq%2FwMIYhAAGgw2Mzc0MjMxODM4MDUiDDkf5P892MHIyfs%2BVSrcA%2BYDl5eywySRkI8kALCpoLV5ulFl34m4ke9KAdMnvT8SXi82cRvIHRIFJzSfbD4mKYJegyLuARwGdkV0CaXv7oZaz%2FCJOPV8os1g5yWLOrwIBL5piorfWQ0nJF65Ep0TauL33xWKST91tT1sQrsvnGqYEX5PVOuGKySwGrubJBoUTLAakw4Sl9Vmsv8yyUe0ZXIOiEE2Eq0wzX81VHau22%2FFWDDS5QMLNmof8nx5aVn7Ox5bHIf9mFnaWXkBFW6JqkixDf9qoEa0DaD9RgrO5upSQFR6cRyKhRcVRCW7HzN3moiZTzwK3Py7TZ24u9fCt9V8tzRiheT0GXwZgb9dtsm44mEM8CkrLIluiDCxDRHjmiiB2NpVxlEteGJmrilN1vVf2f%2BccEPcM6DiautX7NV8%2BJBXiVIJTAtBBQYE3Pw8APtor3aByQWFvA8GaVzyhBRrFTyapdyqlt3r7GNqaXHURxVYxhnzN5N7j3vvIya%2B1GKyr5JCTZaBLGoRG63OBLblO7HibEj5rfTdmk2s%2F14wlrrDz8rB7g6od3X9CI%2BoG1AGClLx6FwdKfvHqugu7xzLw2IdTJqtAEN8TEaK3vByFlPcLyBe%2BpnkfC%2FURWVUQdLa1zWJRdGu6pvGMMfnvMoGOqUBsSps4zPsUnaPWg0iJhtRbfvtZnhN3%2B8Jizc7F3x2yxE2ycRYP3SvMqdSo%2BCE0LVBlPGURQNLJiZKqpqWLc9Ogvblef8TDMTaYOttWACiROBoT3xCMF%2F49dhKREarZRltn5YAsQ7hnqnE9AM3IDyW3qmfxkJvy4uqLhVRJwm72z%2FHescxg4pR6s9pxZ2imRiXbh9TWz%2BOrFyZvGUCwBiPiJ31Vk7u&X-Amz-Signature=18c04d57d99f32a9a3ff1e21d3228604f2d42ddce18184c69deb6da2cbf24a0a&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=3-提示词工程-prompt-engineering>3. 提示词工程 (Prompt Engineering)<a hidden class=anchor aria-hidden=true href=#3-提示词工程-prompt-engineering>#</a></h3><p>提示词工程是指精心设计输入给模型的提示词，以便引导模型产生更符合期望的输出。这种技术特别适用于那些基于自然语言处理的大规模预训练模型。通过调整提示词的内容、结构以及语气，可以显著影响模型生成的结果。例如，在某些场景下，使用更正式的语言或提供更多的上下文信息可以促使模型生成更为准确和连贯的回答。提示词工程还可以用来控制生成内容的风格、语气甚至创造力水平。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/792da3ef-3da1-4135-87c7-49330fd2c438/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=684facfc00f289cb4691096d11e8c65af836469402c9dbfb63836e32b96c0e37&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=4-检索增强生成retrieval-augmented-generation-rag>4. 检索增强生成(Retrieval-Augmented Generation, RAG)<a hidden class=anchor aria-hidden=true href=#4-检索增强生成retrieval-augmented-generation-rag>#</a></h3><p>检索增强生成是一种结合了检索技术和生成模型的方法，它允许模型在生成答案或内容时参考一个外部的知识库。这样做的好处是可以利用大量静态或动态的信息来增强生成的质量，特别是在处理那些需要精确信息或最新数据的任务时。RAG可以提升生成内容的相关性和准确性，尤其是在对话系统、问答系统或文本摘要等领域。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/a68e13a0-8b00-48a2-8cdc-d3fa07143d40/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=8aff867fbe846978d224ef9a348a36e8a454cb392136a07c6d23aec92e691d12&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=5-微调预训练模型>5. 微调预训练模型<a hidden class=anchor aria-hidden=true href=#5-微调预训练模型>#</a></h3><p>微调预训练模型是指在一个已经预先训练好的模型基础上，针对特定任务进一步训练模型的过程。预训练模型通常是在大规模数据上训练得到的，拥有良好的通用特征提取能力。通过在特定任务的小数据集上继续训练，可以使得模型更加专注于解决该任务，从而提升模型在特定领域或任务上的表现。</p><p>微调各种尺寸大模型的硬件要求</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/ae097008-5a4f-4721-820a-9c54193ad647/LLM-tuning-17.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=67b5c6ae5ee791db7f3b4ed07374fce2e33df0c0f5cc0b059cd93effa2f08653&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=51-有监督微调sft>5.1 有监督微调(SFT)<a hidden class=anchor aria-hidden=true href=#51-有监督微调sft>#</a></h3><p>在自然语言处理（NLP）领域，Supervised Finetuning（SFT）是一种至关重要的技术手段，用来提升大模型在某一特定领域的表现。通过精细的策划和实施，SFT 能够指导模型的学习过程，确保其学习成果与既定目标高度吻合。</p><p>SFT 指的是，用户提供一份标注好的数据集，即，包含输入的 prompt 和预期输出的 response。然后，在已有的某个基座模型上继续调整参数，来达到和下游任务对齐的目的。</p><h3 id=511-什么时候需要用到sft->5.1.1 什么时候需要用到SFT ?<a hidden class=anchor aria-hidden=true href=#511-什么时候需要用到sft->#</a></h3><ol><li>通过提示词工程无法解决或提示词中描述过于复杂时。</li><li>对大模型输出内容有格式要求时，而模型仍有部分条件不符合要求。</li><li>期望通过 SFT 来减少 prompt 中的内容，加速线上推理的耗时。</li></ol><h3 id=512-sft数据格式>5.1.2 SFT数据格式<a hidden class=anchor aria-hidden=true href=#512-sft数据格式>#</a></h3><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/ee102fa2-438d-41e7-908c-4a827b1d73cb/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025252Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=7839d0349cebd0d748b33c5510d5732a5322273c673b86382658f9c226eae686&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><p>每行一条JSON格式的数据：</p><ul><li>messages (list, required): 描述一个对话列表。</li><li>role (str, required): 角色，system、user、assistant中的一个。</li><li>content (str, required): 对话内容文本。</li><li>loss_weight (float, optional): 对于内容的loss训练权重。当role=system/user，loss_weight默认值为0.0且不可修改；当role=assistant，loss_weight默认值为1.0。通过loss_weight字段，可以在训练数据中修改默认值。</li></ul><h3 id=513-sft微调所需数据量级>5.1.3 SFT微调所需数据量级<a hidden class=anchor aria-hidden=true href=#513-sft微调所需数据量级>#</a></h3><p>模型中 SFT 的过程中，会学习 prompt 到 response 到映射关系，如果我们 SFT 的数据存在噪声（如错别字、错误格式、不符合预期输出的样本等），那么会对模型的训练过程造成比较严重的影响。因此，不可以一味去堆叠 SFT 的样本数量，样本的质量比数量更重要。</p><p>针对不同场景下，数据量级的建议：</p><ul><li>文案生成，剧本创作，小说续写等生成类任务：2～3k。</li><li>参考问答：2k ~ 1w。</li><li>文本分类：1～3k，和类别数量以及任务难易度强相关，类别较多/任务较难的场景可能需要1w条以上。</li></ul><h3 id=52-lora微调>5.2 LoRA微调<a hidden class=anchor aria-hidden=true href=#52-lora微调>#</a></h3><h3 id=521-什么是lora->5.2.1 什么是LoRA ?<a hidden class=anchor aria-hidden=true href=#521-什么是lora->#</a></h3><p>LoRA（Low-Rank Adaptation of Large Language Models），直译为大语言模型的低阶自适应。LoRA 的基本原理是冻结预训练好的模型权重参数，在冻结原模型参数的情况下，通过往模型中加入额外的网络层，并只训练这些新增的网络层参数。由于这些新增参数数量较少，这样不仅 finetune 的成本显著下降，还能获得和全模型参数参与微调类似的效果。</p><p>随着大语言模型的发展，模型的参数量越来越大，比如 GPT-3 参数量已经高达 1750 亿，因此，微调所有模型参数变得不可行。LoRA 微调方法由微软提出，通过只微调新增参数的方式，大大减少了下游任务的可训练参数数量。</p><h3 id=522-lora微调方法的基本原理>5.2.2 LoRA微调方法的基本原理<a hidden class=anchor aria-hidden=true href=#522-lora微调方法的基本原理>#</a></h3><p>神经网络的每一层都包含矩阵的乘法。这些层中的权重矩阵通常具有满秩。当适应特定任务时，预训练语言模型具有低的 “内在维度”，将它们随机投影到更小的子空间时，它们仍然可以有效地学习。</p><p>在大语言模型微调的过程中，LoRA 冻结了预先训练好的模型权重，并将可训练的秩的分解矩阵注入到 Transformer 体系结构的每一层。例如，对于预训练的权重矩阵W0，可以让其更新受到用低秩分解表示后者的约束：</p><ul><li>跟踪权重的变化而不是直接更新它们。</li><li>将大型权重矩阵分解为包含“可训练参数”的较小矩阵。
<img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/9457c0bc-fb67-4e56-9ff6-89cae4b4842d/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=7a16e24d6155551161380a1315f76f4cb1ca071e889e4888773809a575d85b1a&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></li></ul><h3 id=523-lora微调的优势>5.2.3 LoRA微调的优势<a hidden class=anchor aria-hidden=true href=#523-lora微调的优势>#</a></h3><ol><li>可训练参数显着减少，从而实现更快、更高效的微调。</li><li>保留原始的预训练权重，允许针对不同任务使用多个轻量级模型。</li><li>与其他参数高效方法兼容，可实现进一步优化。</li><li>在许多情况下，其性能可与完全微调的模型相媲美。</li><li>没有额外的推理延迟，因为适配器权重可以与基本模型合并。</li></ol><h3 id=524-qlora微调>5.2.4 QLoRA微调<a hidden class=anchor aria-hidden=true href=#524-qlora微调>#</a></h3><p>QLoRa 通过量化可训练参数，用更少的位数表示它们，使 LORA 更进一步。这进一步减小了模型大小，有可能实现在内存和计算资源有限的设备上的部署。</p><h3 id=53-freeze微调>5.3 Freeze微调<a hidden class=anchor aria-hidden=true href=#53-freeze微调>#</a></h3><p>Freeze 方法，即参数冻结，对原始模型部分参数进行冻结操作，仅训练部分参数，以达到在单卡或不进行 TP 或 PP 操作，就可以对大模型进行训练。在语言模型模型微调中，Freeze 微调方法仅微调 Transformer 后几层的全连接层参数，而冻结其它所有参数。</p><h3 id=54-galore微调>5.4 GaLore微调<a hidden class=anchor aria-hidden=true href=#54-galore微调>#</a></h3><p>GaLore 是一种允许全参数学习的训练策略，但比常见的低秩自适应方法（例如 LoRA）更节省内存。GaLore 关键思想是利用权重矩阵 W 的梯度缓慢变化的低秩结构，而不是试图将权重矩阵直接近似为低秩形式。使得在消费级GPU上训练大型语言模型成为可能。这一策略为未来的大模型训练提供了重要的技术支持，具有广泛的应用前景。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/5c06916a-5e41-46e1-872e-79b0665630dd/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=8f76c0476f5500c81e3cc5bb9f397386487ad4f9aa3a498f3fbe430f049ef68f&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=6-代理agent>6. 代理(Agent)<a hidden class=anchor aria-hidden=true href=#6-代理agent>#</a></h3><p>增加辅助代理是指在主要模型之外引入其他小模型或组件，这些辅助代理可以帮助主模型更好地完成任务。辅助代理可能负责不同的子任务，如噪声过滤、特征增强、错误检测等，它们的工作成果可以作为额外的信息提供给主模型，从而帮助主模型做出更准确的决策。这种方法可以提高系统的鲁棒性和灵活性，使其在复杂环境中表现出色。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/8bfc6fd2-b9fe-4d7a-9311-f02a2cebba1c/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=6882c105158dbd58f0f1124c0b7b3e5a4a51b3a4981682831193d9b140c21896&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><hr><h2 id=模型结构>模型结构<a hidden class=anchor aria-hidden=true href=#模型结构>#</a></h2><h3 id=1-模型深度与宽度的平衡>1. 模型深度与宽度的平衡<a hidden class=anchor aria-hidden=true href=#1-模型深度与宽度的平衡>#</a></h3><p>在语言模型中，增加模型的深度可以使其捕获更复杂的语言结构，而增加宽度则可以提供更多的表达能力。然而，深度和宽度的增加都会带来更高的计算成本和潜在的过拟合风险。可以通过实验来确定最优的层数和每层的隐藏单元数，找到一个既能提高模型性能又不会过度增加训练时间的平衡点。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/ed2f2dc3-741b-4f07-97d1-1758617b0cb0/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=3f994f361321b9f8b6e229e42421b5230a52087d2f83c64b88d9a7d0c93395c8&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=2-残差连接>2. 残差连接<a hidden class=anchor aria-hidden=true href=#2-残差连接>#</a></h3><p>在语言模型中引入残差连接可以帮助模型更好地学习长期依赖关系，并减轻梯度消失的问题。通过让信息流绕过一层或多层，模型可以更容易地学习到输入与输出之间的映射关系。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/1f095e25-7883-460a-827b-a3a6ef251c3d/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=f5aa73c6bba293bfc28ee04cce9835acc97a9b798f39ba9e2519525664adda58&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=3-注意力机制>3. 注意力机制<a hidden class=anchor aria-hidden=true href=#3-注意力机制>#</a></h3><p>在语言模型中使用自注意力机制，可以让模型学习到输入序列中不同位置之间的相关性。这种机制尤其适合处理变长的输入序列，因为它能够动态地为不同位置的词分配不同的权重。</p><h3 id=4-多头注意力>4. 多头注意力<a hidden class=anchor aria-hidden=true href=#4-多头注意力>#</a></h3><p>通过将注意力机制分成多个头，每个头可以独立地关注输入的不同方面。这种方式能够增强模型对输入的多样性和复杂性的理解，从而提升整体性能。</p><h3 id=5-transformer架构>5. Transformer架构<a hidden class=anchor aria-hidden=true href=#5-transformer架构>#</a></h3><p>即便不采用卷积，也可以使用基于注意力机制的Transformer架构来构建语言模型。这种架构通过完全依赖自注意力机制来处理序列数据，避免了传统RNN中顺序依赖的问题，并且能够并行化训练过程，加快训练速度。即便不采用卷积，也可以使用基于注意力机制的Transformer架构来构建语言模型。这种架构通过完全依赖自注意力机制来处理序列数据，避免了传统RNN中顺序依赖的问题，并且能够并行化训练过程，加快训练速度。</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/d5fde343-eabb-4fa7-a68a-fa2b444c8815/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=17a93f8ce93f8b818c3898f0ab6b6d243f0cb09bc1db160e01aac60a3a5582c1&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=6-正则化技术>6. 正则化技术<a hidden class=anchor aria-hidden=true href=#6-正则化技术>#</a></h3><p>为了防止过拟合，可以在模型中加入正则化技术，比如Dropout，它通过在训练过程中随机关闭一部分神经元来提高模型的鲁棒性。此外，还可以使用权重衰减等其他形式的正则化来约束模型复杂度。</p><p>应用于标准神经网络的Dropout</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/fc551d39-65de-4266-bbeb-b0dd3000d660/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=86565405945d44694fde664f031d23a651930e5fd23ffb7d1b5f2f57924700b5&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><h3 id=7-混合专家mixture-of-experts-moe>7 混合专家(Mixture of Experts, MoE)<a hidden class=anchor aria-hidden=true href=#7-混合专家mixture-of-experts-moe>#</a></h3><p>在语言模型中，MoE架构允许模型根据输入选择不同的专家来处理，从而在不增加太多参数的情况下提高模型的容量和表现力。这种方式特别适用于需要处理多种类型数据的语言任务。</p><p>MoE架构的核心组件</p><p><img loading=lazy src="https://prod-files-secure.s3.us-west-2.amazonaws.com/fc187c04-cf34-444f-b5f2-bdcdfad76660/ba4c20e8-eca9-4863-9a9b-f19d237576aa/image.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB46637SMCXJS%2F20251227%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251227T025253Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEJr%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaCXVzLXdlc3QtMiJIMEYCIQDE8RTxWU3Nsprp%2B6XvI8iQ%2BJqlHjliEnIk5WcBrpChGAIhAP0sCdMSn6lOlIpOEaqsTqnuJpKDeltobN2xGfzfnwBoKv8DCGMQABoMNjM3NDIzMTgzODA1IgweFKkSUtCLP6AQnoEq3APvCJrCY7I3x0b2eLjrQ7s8vetkXs9DiSR6SjV3qlUtaPYP6SSyRB9wAEkikuGYZJ7pl2EpnQIHnHWuaPNB2nCh2e%2FM1Vf6cU5VlsP135O44Y5yirdw3ggIMhGdbMoeQXz2qEG%2BLvSYt4SHRS6ksedlGSmc6H0hIWott5KTNR5h4gjdJBdDkTcX%2Bb78wNHjUJYNGSaU2kPpV%2Fw2W%2BY9v5V%2FAtNnCh5GD7bm8Xc8oXk%2BO4RbxX%2BpXUwJ1WMo3uuf9fG7oPFjwUjFix9e2Z3yHKfoPILSxZQhPFeVHsmJR5st1cpCS7O3dwYluJcehRmCTmjQ9IuNTj7u7K2%2F8EQFnw5rg0dkwLQFi4TRagod6BVgLYcNMIaOEe6zGwWaPlnzAYPqrpuw0%2BlQDl82eNcAyaDMZYkdnD8MyPQuWwKwKLhc%2BBO3ad7%2Fn2Du0BBANwEJ9fk0VDZ3F%2FJHMDrK2vFe8CXfKmgtHLdXXsNLBEHjFhtTySQHOInvZzhmyNbGxNnRjGf71OeB8N8zjq8mAVnx5FY3%2FAC2h3i4WyHoxRHaqcJaG%2BrLgEoK7Qs189lIa8SlGIw4xjHitmPMyqd9Ajjt3fxussXQds2%2Ffz4Jmz4sRDwRxv4QU%2FuNeCMLEsZ5xTC%2F7LzKBjqkAcEmeEnekS3URneloJhc8mz5Q26avgLY90cEY8D4kozepw8DWx6AOrCC4WEfgmz9QUy2LYXCa11ml8XG3W1iLdC2Rqkqbnk2lKjg7QR64p7mdoUQs%2BsHpgTsM2cjozBL7uVJYSNUog5KhKYvd5LXQX%2Bh64DiVi70VMxY4rzap%2Fb%2BnM5vYhjDV4FwSmQHM8E%2BiltiZT65PwC%2BlY%2Bid8EESxv49YPP&X-Amz-Signature=8e91fbf09556970387345523ec826406dd383ff88c2bbc27a122c313f1be1839&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject"></p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://Pan-Binghong.github.io/daily-learning/tags/knowledge/>Knowledge</a></li></ul><nav class=paginav><a class=prev href=https://Pan-Binghong.github.io/daily-learning/knowledge/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%91%E7%AE%97%E8%B6%85%E7%AE%97%E6%99%BA%E7%AE%97%E9%80%9A%E7%AE%97/><span class=title>« Prev</span><br><span>什么是云算、超算、智算、通算</span>
</a><a class=next href=https://Pan-Binghong.github.io/daily-learning/knowledge/%E4%BB%80%E4%B9%88%E6%98%AFroceibrdma/><span class=title>Next »</span><br><span>什么是RoCE、IB、RDMA</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on x" href="https://x.com/intent/tweet/?text=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8&amp;url=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f&amp;hashtags=Knowledge"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f&amp;title=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8&amp;summary=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8&amp;source=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f&title=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on whatsapp" href="https://api.whatsapp.com/send?text=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8%20-%20https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on telegram" href="https://telegram.me/share/url?text=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8&amp;url=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share LLM调优方法|巨™全 on ycombinator" href="https://news.ycombinator.com/submitlink?t=LLM%e8%b0%83%e4%bc%98%e6%96%b9%e6%b3%95%7c%e5%b7%a8%e2%84%a2%e5%85%a8&u=https%3a%2f%2fPan-Binghong.github.io%2fdaily-learning%2fknowledge%2fllm%25E8%25B0%2583%25E4%25BC%2598%25E6%2596%25B9%25E6%25B3%2595%25E5%25B7%25A8%25E5%2585%25A8%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer><div class=comments-section><hr class=comments-divider><div class=giscus-comments><h3 class=comments-title>💬 评论讨论</h3><p class=comments-hint>使用 GitHub 账号登录即可参与讨论。评论将同步到
<a href=https://github.com/Pan-Binghong/daily-learning/discussions target=_blank rel=noopener>GitHub Discussions</a></p><script src=https://giscus.app/client.js data-repo=Pan-Binghong/daily-learning data-repo-id=R_kgDONYfgVw data-category=Announcements data-category-id=DIC_kwDONYfgV84CkvE7 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></div></div><style>.comments-section{margin-top:3rem}.comments-divider{margin:2rem 0;border:none;border-top:2px solid var(--border)}.comments-title{font-size:1.5rem;margin-bottom:1rem;color:var(--primary)}.comments-hint{font-size:.9rem;color:var(--secondary);margin-bottom:1.5rem;padding:1rem;background:var(--code-bg);border-radius:8px;border-left:4px solid var(--primary)}.comments-hint a{color:var(--primary);text-decoration:underline}.giscus-comments{margin-top:2rem}</style></article></main><footer class=footer><span>&copy; 2025 <a href=https://Pan-Binghong.github.io/daily-learning/>Pan Binghong's Tech Blog</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg></a><div class=reading-progress-bar id=reading-progress></div><script>window.addEventListener("scroll",function(){const e=document.getElementById("reading-progress");if(!e)return;const t=window.innerHeight,n=document.documentElement.scrollHeight-t,s=window.scrollY,o=s/n*100;e.style.width=o+"%"}),document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".copy-text");e.forEach(e=>{e.addEventListener("click",function(){this.textContent="✓ 已复制",setTimeout(()=>{this.textContent="复制"},2e3)})})}),document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll('a[href^="http"]');e.forEach(e=>{e.hostname!==window.location.hostname&&(e.setAttribute("target","_blank"),e.setAttribute("rel","noopener noreferrer"))})}),document.addEventListener("DOMContentLoaded",function(){const e=document.querySelectorAll(".post-content img");e.forEach(e=>{e.style.cursor="pointer",e.addEventListener("click",function(){window.open(this.src,"_blank")})})})</script><style>#top-link{transition:all .3s ease}#top-link:hover{transform:translateY(-5px);box-shadow:0 5px 15px rgba(0,0,0,.2)}</style><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>